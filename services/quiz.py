from typing import List
from uuid import UUID
from sqlmodel.ext.asyncio.session import AsyncSession
from sqlmodel import func, select
from sqlalchemy.orm import selectinload
from app.core.exceptions import ValidationError
from app.db.models import QuizAttempt, QuizResponse
from app.core.config import settings
from app.core.logging import logger
from app.utils.format_quiz_instruction import format_quiz_instruction
from app.schemas.quiz_attempt import QuizAttemptStatus, QuizAttemptResponseSchema, QuizResponseSchema

import json
from google import generativeai


async def has_completed_adventure_quiz(
    profile_id: UUID,
    quiz_id: UUID,
    session: AsyncSession
) -> bool:
    
    try:
        
        result = await session.exec(
            select(QuizAttempt)
            .where(
                (QuizAttempt.profile_id == profile_id) &
                (QuizAttempt.quiz_id == quiz_id) &
                (QuizAttempt.status == QuizAttemptStatus.FINISHED.value)
            )
        )
        
        if result.first():
            return True 
        
        return False
        
    except Exception as e:
        raise


async def get_or_create_quiz_attempt(
    profile_id: UUID,
    quiz_id: UUID,
    session: AsyncSession
):
    try:
        result = await session.exec(
            select(QuizAttempt)
            .options(
                selectinload(QuizAttempt.responses).selectinload(QuizResponse.question),
                selectinload(QuizAttempt.quiz)
            )
            .where(
                (QuizAttempt.profile_id == profile_id) &
                (QuizAttempt.quiz_id == quiz_id) &
                (QuizAttempt.status == QuizAttemptStatus.IN_PROGRESS.value)
            )
        ) 
        ongoing_attempt = result.first()
        
        new_attempt = None
        
        # Count previous attempts
        attempt_count_result = await session.exec(
            select(func.count())
            .where(
                (QuizAttempt.profile_id == profile_id) & 
                (QuizAttempt.quiz_id == quiz_id)
            )
        )
        attempt_count = attempt_count_result.one() or 0
        
        if not ongoing_attempt:
            new_attempt = QuizAttempt(
                quiz_id=quiz_id,
                profile_id=profile_id,
            )
            session.add(new_attempt)
            await session.commit()
            await session.refresh(new_attempt)
            attempt_count+=1
            
        response_obj = new_attempt or ongoing_attempt
            
        return QuizAttemptResponseSchema(
            id=response_obj.id,
            profile_id=profile_id,
            quiz_id=quiz_id,
            status=response_obj.status,
            created_at=str(response_obj.created_at),
            attempt_no=attempt_count if attempt_count!= 0 else 1,
            responses=[
                QuizResponseSchema(
                    id=str(response.id),
                    attempt_id=response_obj.id,
                    question_id=response.question_id,
                    question_text=response.question.text, 
                    choices=response.question.choices if response.question.choices else None,
                    correct_answer=response.question.correct_answer if response.question.correct_answer else None,
                    chosen_answer=response.answer if response.answer else None,
                    is_correct=response.is_correct if response.is_correct else None,
                    created_at=str(response.created_at),
                    updated_at=str(response.updated_at) if response.updated_at else None,
                ) for response in response_obj.responses
            ] if response_obj.responses else []
        )
        
    except Exception as e:
        raise
    
    
def get_rating(attempt: QuizAttempt) -> int:
    if not attempt.responses and attempt.status != QuizAttemptStatus.FINISHED.value:
        return 0
    correct_answers = sum(1 for response in attempt.responses if response.is_correct)
    return correct_answers
    
    
def format_quiz_text_into_request(text: str) -> List[dict]:
    """Formats a quiz text into a structured request using Gemini Flash 1.5.
    This function takes a quiz text input, configures Gemini, and generates
    a structured response based on the provided text and instructions. If the model fails
    to generate a meaningful response, it raises a `ValidationError`.
    Args:
        text (str): The quiz text to be formatted into a structured request.
    Returns:
        dict: A JSON-parsed dictionary containing the structured response generated by the model.
    Raises:
        ValidationError: If the model cannot make sense of the quiz document.
        Exception: For any other unexpected errors during processing.
    """
    try: 
        
        generativeai.configure(api_key=settings.GEMINI_KEY)
        model = generativeai.GenerativeModel(model_name='gemini-2.5-flash')
        
        prompt = f"""
        QUIZ:
        {text}
        
        INSTRUCTION: 
        {format_quiz_instruction}
        """
        
        response = model.generate_content(prompt)
        
        if response.text == "None":
            logger.error("Couldn't make sense of quiz document")
            raise ValidationError(
                message="Couldn't make sense of quiz document",
            )
        print(response.text)
        
        return json.loads(str(response.text))
    
    except ValidationError as e:
        raise
            
    except Exception as e:
        logger.error(f"Error formatting quiz: {str(e)}")
        raise
        
    